### ⚡️ Promise

```js
var 프로미스 = new Promise();

프로미스.then(function () {}).catch(function () {});
```

new Promise() 문법으로 프로미스라는 변수 오브젝트를 하나 생성하면 Promise 제작 끝이다. <br>
그럼 이제 프로미스라는 변수에다가 then()을 붙여서 실행가능하다.<br>
<br>
프로미스 안의 코드가 실행이 완료가 되었을 때 then() 함수 내의 코드를 실행시켜준다.<br>
코드가 실행이 실패했을 경우엔 catch() 함수 내의 코드를 실행시켜준다.<br>
<br>
이런 식으로 코드를 차례로 실행할 수 있게 도와주는 디자인 패턴이 Promise이다.<br>

#### Promise가 콜백함수보다 좋다고 하는 이유 2가지

- 콜백함수와는 다르게 순차적으로 뭔가를 실행할 때 코드가 옆으로 길어지지 않는다.
  then 함수를 붙여서 순차적으로 실행하기 때문
- 콜백함수는 불가능한 '실패시 특정 코드를 실행해주세요~'라고 코드를 짤 수 있다.
  (catch)

### Promise의 정확한 뜻과 사용법

**성공하면 then(), 실패하면 chath()를 실행해주세요~**<br>
라는 코드를 짤 수 있게 도와주는게 바로 Promise이다.<br>
그럼 Promise는 성공과 실패 상황을 알려준다. 그래서 Promise를 쉽게 정의하자면 성공&실패 판정기계<br>
<br>
Promise 기계 안에는 아무거나 다 집어넣을 수 있다.<br>
1 + 1 연산이 끝나면 성공판정 내려주세요~<br>
페이지 내의 `<button>`을 누르면 성공으로 판정해주세요~<br>
Ajax 요청으로 서버의 데이터를 가져오면 성공판정, 에러나면 실패판정해주세요~<br>
아무거나 다 집어넣을 수 있다.<br>

Promise 안에서 성공/실패를 판정하는 방법은 쉽다.<br>

```js
var 프로미스 = new Promise(function (성공, 실패) {
  성공();
});

프로미스.then(function () {}).catch(function () {});
```

Promise()안에 콜백함수를 하나 추가해주면 그 안에서 성공/실패 판정을 내릴 수 있다.<br>
성공()이라고 첫째 파라미터를 함수형태로 작성하면 성공판정이 된다.<br>
실패()라고 둘째 파라미터를 함수형태로 작성하면 실패판정이 된다.<br>
위의 코드는 무조건 성공()을 실행하게 되어있으니 무조건 성공을 판정내리며<br>
그 후엔 이제 then()안의 코드가 실행이 된다.<br>
<br>

#### 예시1. 힘든 수학연산 성공 후에 특정 코드를 실행하려면?

Promise 활용하기

```js
var 프로미스 = new Promise(function (성공, 실패) {
  var 어려운연산 = 1 + 1;
  성공();
});

프로미스
  .then(function () {
    console.log("연산이 성공했습니다");
  })
  .catch(function () {});
```

Promise()안에 어려운 수학 연산을 해주는 기능을 추가했다.<br>
그리고 그 연산이 완료되면 성공() 코드를 실행하도록 코드를 추가했다.<br>
(일반 코드들은 저렇게 위아래로 나란히 적으면 그냥 차례로 실행된다)<br>
<br>

then 함수 안에는 프로미스가 성공판정을 내리면 실행할 코드를 담을 수 있다.

1. 이제 프로미스 내의 1+1 수학연산이 완료되면 성공()판정을 내리며,
2. 성공시 then()내의 코드를 실행해준다.

Promise 내에선 특정 상황시 실패판정을 내릴 수도 있다.

```js
var 프로미스 = new Promise(function (성공, 실패) {
  var 어려운연산 = 1 + 1;
  실패();
});

프로미스
  .then(function () {
    console.log("연산이 성공했습니다");
  })
  .catch(function () {
    console.log("실패했습니다");
  });
```

실패()라는 함수를 실행하는 순간 실패판정을 내린다.<br>
그렇게 되면 catch()내의 코드를 실행해준다.<br>
실패의 경우 다른 내용을 실행해줄 수도 있으니 그냥 콜백함수 디자인보다 훨씬 직관적이고 유용하다.<br>
<br>

**참고: 연산결과같은걸 then 안에서 활용하고 싶으면 성공()함수 구멍안에 넣어주면된다.**

```js
var 프로미스 = new Promise(function (성공, 실패) {
  var 어려운연산 = 1 + 1;
  성공(어려운연산);
});

프로미스
  .then(function (결과) {
    console.log("연산이 성공했습니다" + 결과);
  })
  .catch(function () {
    console.log("실패했습니다");
  });
```

#### 예시2. 1초 대기 성공 후에 특정 코드 실행하기

```js
var 프로미스 = new Promise(function (성공, 실패) {
  setTimeout(function () {
    성공();
  }, 1000);
});

프로미스
  .then(function () {
    console.log("1초 대기 성공했습니다");
  })
  .catch(function () {
    console.log("실패했습니다");
  });
```

#### Promise의 몇가지 특징

1. 일단 new Promise()로 생성된 변수를 콘솔창에 출력해보면 현재 상태를 알 수 있다.
   성공/실패 판정 전에는`<pending>` 이라고 나오며 성공후엔 `<resolved>` 실패후엔 `<rejected>` 이런식으로 나온다.
   이렇게 프로미스 오브젝트들은 3개 상태가 있다.
   그리고 성공을 실패나 대기 상태로 다시 되돌릴 순 없다.
   <br>

2. Promise는 동기를 비동기로 만들어주는 코드가 아니다.
   Promise는 비동기적 실행과 전혀 상관이 없다.
   코딩을 예쁘게 할 수 있는 일조으이 디자인 패턴이다.
   예를 들어 Promise 안에 10초 걸리는 어려운 연산을 시키면 10초동안 브라우저가 멈춘다.
   (자바스크립트는 평상시엔 동기적으로 실행이 되며 비동기 실행을 지원하는 특수한 함수들 덕분에 가끔 비동기적으로 실행이 될 뿐이다.)
