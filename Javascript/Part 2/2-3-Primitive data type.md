# ⚡️ Primitive data type

자바스크립트의 자료형(문자, 숫자, array, object 등)은 자료형을 크게 2개로 분류한다. <br>
Primitive & reference라고 분류하는데 <br>
Primitive data type들은 자료 자체가 변수에 저장되는 자료들이다. <br>
문자, 숫자 자료형들이 대표적인 Primitive data type들이다. <br>

```js
var name = "john";
var age = 20;
```

이렇게 문자나 숫자 자료형은 문자나 숫자가 변수에 직접 저장된다는 소리다. <br>

## Reference data type

Array, Object 자료형은 referenece data type에 속한다. <br>
referenece data type은 자료를 변수에 직접 저장하는게 아닌, <br>
자료가 저쪽에 있습니다 라는 화살표(레퍼런스)를 변수에 저장한다.<br>

```js
var 사람 = { name: "Kim" };
```

방금 { name : 'Kim' } 이라는 자료를 변수에 저장했다 <br>
하지만 변수에 저장된건 { name : 'Kim' } 이게 아니다.<br>
"{ name : 'Kim' }이 저기 저장되어있습니다"라는<br>
**{ name : 'Kim' } 값을 가리키는 화살표**가 저장이 되어있을 뿐이다<br>
Kim이라는 데이터가 변수에 저장된게 아니고, Kim이란느게 저기 있습니다~ 라는 정보만 저장할 뿐이다.<br>
그래서 이런 reference만 저장되는 array, object 자료형을 referenece data type이라고 한다.<br>

#### Q.화살표가 가리키는 저기가 어디?

A. 컴퓨터 메모리 상의 어떤 곳이다.그냥 우리는 컨트롤할 수 없는 미지의 공간이라고 생각하면 된다.

### 예제 1. 복사하면 이상한 일이 일어난다.

한번 아주 직관적이고 간단한 Primitive 자료형부터 복사해보자

```js
var 이름1 = "김";
var 이름2 = 이름1;
이름1 = "박";
```

(1) 이름1은 '김'이라는 문자를 집어넣었고<br>
(2) 이름2는 이름1에 있던 자료를 복사해서 집어넣는다.<br>
(3) 셋재줄에서 이름1을 심심해서 박으로 변경했다.<br>
**그럼 이름1, 이름2를 출력하면?**
<br>
이름1은 변경했으니 '박'이고, 이름2는 복사만했지 변경하진 않았으니 '김'이다.<br>
근데 똑같은 일을 reference data type으로 진행하면 이상한 일이 일어난다.<br>
<br>

Reference 타입 자료형인 **object를 이용해 똑같이 해보자**

```js
var 이름1 = { name: "김" };
var 이름2 = 이름1;
이름1.name = "박";
```

(1) 이름1은 { name : '김' } 이라는 object자료형을 집어넣었고<br>
(2) 이름2는 이름1에 있던 자료를 복사해서 집어넣었다. <br>
(3) 셋째줄에서 이름1 object 안의 name을 박으로 변경다. <br>
**그럼 이름1, 이름2를 출력하면?**<br>
<br>

이름1은 변경했으니 { name : '박' }이고, 이름2는 복사만했지 변경하진 않았으니 { name : '김' }이다.<br>
그런데 콘솔창에서 출력해보면 이상한 점이 있다.<br>

![](https://velog.velcdn.com/images/hosickk/post/e51dde80-6a46-40f8-83ea-40cb42dc44b1/image.png)
분명 코드를 보면

```js
var 이름1 = { name: "김" };
var 이름2 = 이름1;
이름1.name = "박";
```

**이름2는 우리가 값을 전혀 수정한 적이 없는데 바뀌어 있다.** <br>
왜 그러냐면 두번째줄이 문제이다.<br>
이름2에 이름1을 복사해서 집어넣을 때가 문제이다.<br>
이 때, 이름1에 있던 { name : '김' }이라는 데이터가 복사된게 아니다.<br>
왜냐면 이름1에는 {} 이게 저장된게 아니라 **reference(화살표)가 저장**되어 있다고 했으니<br>
**이름1의 화살표를 이름2에 복사한 것이다.**<br>
이제 이름1과 이름2는 같은 화살표를 가지고 있다.<br>

![](https://velog.velcdn.com/images/hosickk/post/15daeae6-5f27-41c0-9c1f-ce71df6785a3/image.png)
이름1과 이름2는 같은 화살표(reference)를 가지게 된 것이고<br>
그 화살표는 { name : '김' }이라는 같은 값을 가리키고 있는 것일 뿐이다.<br>

그럼 아까 코드에서 셋째줄에서 **이름1.name = '박'** 이렇게 값 변경을 하면 어떻게 될까? <br>
화살표를 타고 들어갓거 name을 '박'으로 설정해준다. <br>
근데 가만히 있던 이름2를 출력해보면 <br>
화살표를 타고 들어가서 { name: '박' } 이라는 데이터가 나오게 되는 것이다. <br>
이런 원리 때문에 이름1과 이름2는 같은 값을 공유하고 있던 것이다. <br>
<br>
결론은 object, array 자료형은 등호로 복사하면<br>
화살표 값을 공유해버리기 대문에 문제가 일어날 수 있다.<br>

### 예제 2. 화살표가 할당되는 기준 & object 두개가 같은지 비교해보기

<br>

새로운 {} object를 할당할 때마다 화살표가 새로 생성된다고 보면 된다.<br>
정확한 명칭은 reference이다.<br>

```js
var 이름1 = { name: "김" };
var 이름2 = { name: "박" };
```

지금 첫줄과 둘째줄 모두 object를 새로 할당해주고 있다.<br>
실은 object가 저기 있다는 화살표를 할당해준 것이다.<br>

```js
var 이름1 = { name: "김" };
var 이름2 = { name: "김" };
```

지금 첫줄과 둘째줄 모두 object를 새로 할당해주고 있다. 근데 object 안의 내용이 똑같다.

#### Q. 바로 위의 예제에서 이름1 == 이름2 이렇게 두개를 같다고 비교하면 true가 나올까요 false가 나올까?

A. false가 나온다.<br>
왜냐면 이름1과 이름2에 저장된건 데이터가 아니라 화살표라고 했다.<br>
== 등호로 비교하고 있는건 지금 object 두개가 아니다. 화살표 두개이다.<br>
화살표가 같으면 (같은 곳을 가리키면)true가 나오고, 화살표가 같지 않으면 false가 나오기 때문이다.<br>
![](https://velog.velcdn.com/images/hosickk/post/ec68d187-e70f-422e-8c22-443f403d519b/image.png)
각각 다른 화살표를 가지고 있기 때문에 이름1과 이름2는 같지 않다.<br>
잘 기억해주면 된다. array도 마찬가지이다. 함부로 같다고 비교하시면 안된다.<br>
굳이 값이 같은지 비교하고 싶으면 이름1.name과 이름2.name을 비교해보자<br>
